# Домашнее задание #08 (память, профилирование)

### 1. Сравнение использования weakref и слотов
Нужно придумать свои типы с несколькими атрибутами:
- класс с обычными атрибутами
- класс со слотами
- класс с атрибутами weakref

Для каждого класса создается большое число экземпляров и замеряется (сравнивается):
- время создания пачки экземпляров
- время чтения/изменения атрибутов

#### Результаты замеров скорости создания и скорости чтения/изменения атрибутов
<image src="result_of_speed_different_classes.png">

В случае с созданием 10**8 экземпляров на 31% быстрее будет класс, использующий слоты вместо обычных переменных. Класс со слабыми ссылками сильно медленнее, тратит в 7 раз больше времени, чем класс со слотами. Это можно объяснить тем, что этот класс использует внутри вызов функции взятия слабой ссылки

### 2. Профилирование
Провести профилирование вызовов и памяти для кода из пункта 1.

#### Результаты замеров затраченной памяти при создания экземпляров

<image src="result_of_memory_using_usual_class.png">

Память занятая 10**5 экземплярами обычного класса равна почти 18 МБ

<image src="result_of_memory_using_slots_class.png">

Память занятая 10**5 экземплярами обычного класса равна 8 МБ. То есть даже в случае хранения 6 ссылок на экземпляры какого-то класса внутри другого, использование `__slots__` помогает кратно сократить количество занимаемой памяти

<image src="result_of_memory_using_weakref_class.png">

Память занятая 10**5 экземплярами обычного класса равна почти 21 МБ. То есть слабые ссылки занимают больше памяти, чем обычные



### 3. Декоратор для профилирования
Применение декоратора к функции должно выполнять прoфилирование (cProfile) всех вызовов данной функции.
Вызов метода `.print_stat()` должен выводить единую таблицу со статистикой профилирования суммарно по всем вызовам функции.


```py
def profile_deco(...):
    ...


@profile_deco
def add(a, b):
    return a + b


@profile_deco
def sub(a, b):
    return a - b


add(1, 2)
add(4, 5)
sub(4, 5)


add.print_stat()  # выводится результат профилирования суммарно по всем вызовам функции add (всего два вызова)
sub.print_stat()  # выводится результат профилирования суммарно по всем вызовам функции sub (всего один вызов)
```

### 4. Перед отправкой на проверку код должен быть прогнан через flake8 и pylint, по желанию еще black
